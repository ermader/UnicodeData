"""/
HeaderToPython. Translate ICU .h files to Pyton

Created on May 6, 2021

@author Eric Mader
"""

from datetime import datetime
import os
import re
from pathlib import Path

firstTokenRE = re.compile(r"([^\s]+)")  # first token on a line
cCommentRE = re.compile(r"/\*\*?(.+?)\*/")  # a /*...*/ comment
eolCommentRE = re.compile(r"//\s*([^$]+)$")  # //... to end of line comment
macroDefineRE = re.compile(r"#define (\w+(?:\(\w+(?:,\s*\w+)?\))?)(?:\s+(.+))?")  # #define with optional arguments and optional value
typedefEnumRE = re.compile(r"typedef\s+enum\s*\w*\s*\{")
endOfEnumRE = re.compile(r"\}\s*\w*\s*;")  # } name ;  with optional name
enumEntryRE = re.compile(r"(\w+)(?:\s*=\s*([^,]+))?(?:,|\s)?")  # id = value,  with optional value and comma

class HeaderFile(object):
    def __init__(self, icuDirectory, cSourcePath, outDirectory, extraCode=[], ignore=[]):
        sourcePath = icuDirectory / cSourcePath
        os.makedirs(outDirectory, exist_ok=True)
        self.sourceFile = open(sourcePath)

        self.ignore = ignore

        self.outputLines = ['"""/']

        todayString = datetime.now().astimezone().strftime("%B %_d, %Y at %I:%M:%S %p %Z")
        toolName = Path(__file__).name
        fromName = sourcePath.name

        headerName = fromName.replace(".", "_").lower()
        outputName = f"{headerName}.py"
        self.headerPath = outDirectory / outputName

        self.outputLines.append(f"{outputName}, based on {fromName} from ICU\n")
        self.outputLines.append(f"Generated by {toolName} on {todayString}")
        self.outputLines.append('"""\n')

        for code in extraCode:
            self.outputLines.append(code)

        self.guardMatch = re.compile(r"\#ifndef\s+(?:__)?" + headerName.upper() + r"(?:__)?\s*$")

    @classmethod
    def firstToken(cls, line):
        return firstTokenRE.findall(line)[0]

    @classmethod
    def getTrailingComment(cls, line):
        comment = None
        if (m := cCommentRE.search(line)) or (m := eolCommentRE.search(line)):
            comment = line[m.start(1):m.end(1)]
            line = line[:m.start()].strip()

        return line, comment

    def nextLine(self):
        inComment = False
        inConditional = False
        inMacro = False
        while (line := self.sourceFile.readline()):
            line = line.strip()
            if not line: continue  # skip over empty lines
            if line.startswith("//"): continue  # skip full-line comment
            if line.startswith("/*"):
                if line.endswith("*/"):
                    continue  # skip a single line comment
                else:
                    inComment = True
                    continue

            if inComment:
                if line.endswith("*/"):
                    inComment = False
                continue

            if line.startswith("#if"):
                if not self.guardMatch.search(line):
                    inConditional = True
                continue

            if inConditional:
                if line.startswith("#endif"):
                    inConditional = False
                continue

            if line.startswith("#endif"): continue  # ignore "endif for __HEADER_H__

            if line.startswith("#define") and line.endswith("\\"):
                inMacro = True
                macroLine = line[:-1]
                continue

            if inMacro:
                if not line.endswith("\\"):
                    inMacro = False
                    return self.getTrailingComment(macroLine + line)
                else:
                    macroLine += line[:-1].strip()
                continue

            return self.getTrailingComment(line)

    def translate(self):
        while (nl := self.nextLine()):
            line, comment = nl
            token = self.firstToken(line)

            if token == "#define":
                # optional argument list, optional value
                name, value = macroDefineRE.findall(line)[0]

                if name in self.ignore: continue

                # maybe check if value is { xxx }...
                if value and not "(" in name:
                    if comment:
                        self.outputLines.append(f"{name} = {value}  # {comment}")
                    else:
                        self.outputLines.append(f"{name} = {value}")
            elif token == "enum" or (token == "typedef" and typedefEnumRE.search(line)):
                nextValue = 0
                variables = {}
                prevName = None
                while (elc := self.nextLine()):
                    eline, comment = elc
                    if endOfEnumRE.search(eline): break

                    name, value = enumEntryRE.findall(eline)[0]
                    if not value:
                        value = str(nextValue)

                    if comment:
                        self.outputLines.append(f"{name} = {value}  # {comment}")
                    else:
                        self.outputLines.append(f"{name} = {value}")

                    intValue = eval(value, variables)

                    variables[name] = intValue
                    nextValue = intValue + 1

                    prevName = name

    def writeFile(self):
        contents = "\n".join(self.outputLines)
        headerFile = open(self.headerPath, "w")
        headerFile.write(contents)
        headerFile.close()

#
# Making the translation "pretty" is a secondary goal - it just needs
# to be functional. i.e. don't worry about comments and blank lines.
#
# (Maybe have a way to get comments from lines that only have a comment)
#

def test():
    icuSource = Path("/Users/emader/Downloads/icu69/icu4c/source")
    testDir = Path("test")
    uprops_h = HeaderFile(icuSource, "common/uprops.h", testDir)
    uprops_h.translate()
    uprops_h.writeFile()


if __name__ == "__main__":
    test()
